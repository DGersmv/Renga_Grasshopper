[1mdiff --git a/RengaGH/Handlers/GetWallsHandler.cs b/RengaGH/Handlers/GetWallsHandler.cs[m
[1mindex 5502086..ae8671b 100644[m
[1m--- a/RengaGH/Handlers/GetWallsHandler.cs[m
[1m+++ b/RengaGH/Handlers/GetWallsHandler.cs[m
[36m@@ -2,6 +2,7 @@[m [musing System;[m
 using System.Collections.Generic;[m
 using System.Linq;[m
 using System.Reflection;[m
[32m+[m[32musing System.IO;[m
 using Renga;[m
 using RengaPlugin.Commands;[m
 using RengaPlugin.Connection;[m
[36m@@ -15,12 +16,26 @@[m [mnamespace RengaPlugin.Handlers[m
     public class GetWallsHandler : ICommandHandler[m
     {[m
         private Renga.IApplication m_app;[m
[32m+[m[32m        private static string logFilePath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "Renga", "RengaGH_GetWalls.log");[m
 [m
         public GetWallsHandler(Renga.IApplication app)[m
         {[m
             m_app = app;[m
         }[m
 [m
[32m+[m[32m        private void LogToFile(string message)[m
[32m+[m[32m        {[m
[32m+[m[32m            try[m
[32m+[m[32m            {[m
[32m+[m[32m                var logDir = Path.GetDirectoryName(logFilePath);[m
[32m+[m[32m                if (!Directory.Exists(logDir))[m
[32m+[m[32m                    Directory.CreateDirectory(logDir);[m
[32m+[m[41m                [m
[32m+[m[32m                File.AppendAllText(logFilePath, $"[{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff}] {message}\n");[m
[32m+[m[32m            }[m
[32m+[m[32m            catch { }[m
[32m+[m[32m        }[m
[32m+[m
         public ConnectionResponse Handle(ConnectionMessage message)[m
         {[m
             try[m
[36m@@ -40,6 +55,25 @@[m [mnamespace RengaPlugin.Handlers[m
                 var objects = model.GetObjects();[m
                 int count = objects.Count;[m
 [m
[32m+[m[32m                // Get exported 3D objects for mesh extraction[m
[32m+[m[32m                var dataExporter = m_app.Project.DataExporter;[m
[32m+[m[32m                var exportedObjects3D = dataExporter?.GetObjects3D();[m
[32m+[m[32m                var exportedObjectsMap = new Dictionary<int, Renga.IExportedObject3D>();[m
[32m+[m[41m                [m
[32m+[m[32m                if (exportedObjects3D != null)[m
[32m+[m[32m                {[m
[32m+[m[32m                    int exportedCount = exportedObjects3D.Count;[m
[32m+[m[32m                    for (int i = 0; i < exportedCount; i++)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        try[m
[32m+[m[32m                        {[m
[32m+[m[32m                            var exportedObj = exportedObjects3D.Get(i);[m
[32m+[m[32m                            exportedObjectsMap[exportedObj.ModelObjectId] = exportedObj;[m
[32m+[m[32m                        }[m
[32m+[m[32m                        catch { }[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m
                 for (int i = 0; i < count; i++)[m
                 {[m
                     try[m
[36m@@ -80,11 +114,15 @@[m [mnamespace RengaPlugin.Handlers[m
                                 }[m
                                 catch { }[m
                                 [m
[31m-                                // Get baseline curve[m
[32m+[m[32m                                // Get baseline curve - try IWall interface[m
                                 object baselineData = ExtractBaselineData(obj);[m
                                 [m
[31m-                                // Get mesh geometry[m
[31m-                                object meshData = ExtractMeshData(modelObject);[m
[32m+[m[32m                                // Get mesh geometry from exported 3D object[m
[32m+[m[32m                                object meshData = null;[m
[32m+[m[32m                                if (exportedObjectsMap.TryGetValue(obj.Id, out var exportedObj3D))[m
[32m+[m[32m                                {[m
[32m+[m[32m                                    meshData = ExtractMeshDataFromExported(exportedObj3D);[m
[32m+[m[32m                                }[m
                                 [m
                                 var wallData = new[m
                                 {[m
[36m@@ -108,7 +146,7 @@[m [mnamespace RengaPlugin.Handlers[m
                     catch (Exception ex)[m
                     {[m
                         // Skip this object if there's an error[m
[31m-                        System.Diagnostics.Debug.WriteLine($"Error processing wall object: {ex.Message}");[m
[32m+[m[32m                        LogToFile($"Error processing wall object: {ex.Message}");[m
                     }[m
                 }[m
 [m
[36m@@ -140,91 +178,90 @@[m [mnamespace RengaPlugin.Handlers[m
         {[m
             try[m
             {[m
[31m-                // Cast to ILevelObject to access wall-specific methods[m
[31m-                var levelObj = wallObj as Renga.ILevelObject;[m
[31m-                if (levelObj == null)[m
[31m-                    return null;[m
[31m-[m
[31m-                // Try multiple approaches to get baseline[m
[31m-                object baseline = null;[m
[32m+[m[32m                // Try to cast to IWall interface (if available)[m
[32m+[m[32m                // For walls, we need to get ICurve3D baseline[m
[32m+[m[32m                Renga.ICurve3D baseline = null;[m
                 [m
[31m-                // Approach 1: Try GetBaseline method via reflection (case-insensitive, check all methods)[m
[32m+[m[32m                // Approach 1: Try casting to IWall interface directly[m
                 try[m
                 {[m
[32m+[m[32m                    // Check if wallObj implements IWall interface[m
                     var wallType = wallObj.GetType();[m
[31m-                    var allMethods = wallType.GetMethods(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);[m
[31m-                    [m
[31m-                    // Look for GetBaseline method (case-insensitive)[m
[31m-                    var getBaselineMethod = Array.Find(allMethods, m => [m
[31m-                        m.Name.Equals("GetBaseline", StringComparison.OrdinalIgnoreCase) && [m
[31m-                        m.GetParameters().Length == 0);[m
[31m-                    [m
[31m-                    if (getBaselineMethod != null)[m
[31m-                    {[m
[31m-                        baseline = getBaselineMethod.Invoke(wallObj, null);[m
[31m-                        System.Diagnostics.Debug.WriteLine($"Found GetBaseline method, result: {(baseline != null ? "not null" : "null")}");[m
[31m-                    }[m
[31m-                    else[m
[32m+[m[32m                    var iWallInterface = wallType.GetInterface("IWall");[m
[32m+[m[32m                    if (iWallInterface != null)[m
                     {[m
[31m-                        System.Diagnostics.Debug.WriteLine($"GetBaseline method not found. Available methods: {string.Join(", ", allMethods.Select(m => m.Name))}");[m
[32m+[m[32m                        var getBaselineMethod = iWallInterface.GetMethod("GetBaseline");[m
[32m+[m[32m                        if (getBaselineMethod != null)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            baseline = getBaselineMethod.Invoke(wallObj, null) as Renga.ICurve3D;[m
[32m+[m[32m                            LogToFile($"Found IWall.GetBaseline, result: {(baseline != null ? "not null" : "null")}");[m
[32m+[m[32m                        }[m
                     }[m
                 }[m
                 catch (Exception ex)[m
                 {[m
[31m-                    System.Diagnostics.Debug.WriteLine($"Error getting baseline via reflection: {ex.Message}\n{ex.StackTrace}");[m
[32m+[m[32m                    LogToFile($"Error trying IWall interface: {ex.Message}");[m
                 }[m
 [m
[31m-                // Approach 2: Try using dynamic[m
[32m+[m[32m                // Approach 2: Try GetBaseline method via reflection (case-insensitive)[m
                 if (baseline == null)[m
                 {[m
                     try[m
                     {[m
[31m-                        dynamic wallDynamic = wallObj;[m
[31m-                        baseline = wallDynamic.GetBaseline();[m
[31m-                        System.Diagnostics.Debug.WriteLine($"Dynamic approach result: {(baseline != null ? "not null" : "null")}");[m
[32m+[m[32m                        var wallType = wallObj.GetType();[m
[32m+[m[32m                        var allMethods = wallType.GetMethods(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);[m
[32m+[m[41m                        [m
[32m+[m[32m                        var getBaselineMethod = Array.Find(allMethods, m =>[m[41m [m
[32m+[m[32m                            m.Name.Equals("GetBaseline", StringComparison.OrdinalIgnoreCase) &&[m[41m [m
[32m+[m[32m                            m.GetParameters().Length == 0);[m
[32m+[m[41m                        [m
[32m+[m[32m                        if (getBaselineMethod != null)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            baseline = getBaselineMethod.Invoke(wallObj, null) as Renga.ICurve3D;[m
[32m+[m[32m                            LogToFile($"Found GetBaseline via reflection, result: {(baseline != null ? "not null" : "null")}");[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else[m
[32m+[m[32m                        {[m
[32m+[m[32m                            LogToFile($"GetBaseline method not found. Available methods: {string.Join(", ", allMethods.Select(m => m.Name).Take(20))}");[m
[32m+[m[32m                        }[m
                     }[m
                     catch (Exception ex)[m
                     {[m
[31m-                        System.Diagnostics.Debug.WriteLine($"Error with dynamic approach: {ex.Message}");[m
[32m+[m[32m                        LogToFile($"Error getting baseline via reflection: {ex.Message}");[m
                     }[m
                 }[m
 [m
[31m-                // Approach 3: Try to get baseline from placement or other properties[m
[32m+[m[32m                // Approach 3: Try using dynamic[m
                 if (baseline == null)[m
                 {[m
                     try[m
                     {[m
[31m-                        // Maybe baseline is accessible through placement or other properties[m
[31m-                        var placement = levelObj.GetPlacement();[m
[31m-                        if (placement != null)[m
[31m-                        {[m
[31m-                            System.Diagnostics.Debug.WriteLine($"Placement found: Origin=({placement.Origin.X}, {placement.Origin.Y}, {placement.Origin.Z})");[m
[31m-                            // Check if there's a way to get baseline from placement[m
[31m-                            // This might not work, but worth trying[m
[31m-                        }[m
[32m+[m[32m                        dynamic wallDynamic = wallObj;[m
[32m+[m[32m                        baseline = wallDynamic.GetBaseline() as Renga.ICurve3D;[m
[32m+[m[32m                        LogToFile($"Dynamic approach result: {(baseline != null ? "not null" : "null")}");[m
                     }[m
                     catch (Exception ex)[m
                     {[m
[31m-                        System.Diagnostics.Debug.WriteLine($"Error getting placement: {ex.Message}");[m
[32m+[m[32m                        LogToFile($"Error with dynamic approach: {ex.Message}");[m
                     }[m
                 }[m
 [m
                 if (baseline != null)[m
                 {[m
[31m-                    return ExtractBaselineFromCurve(baseline);[m
[32m+[m[32m                    return ExtractBaselineFromCurve3D(baseline);[m
                 }[m
 [m
[31m-                System.Diagnostics.Debug.WriteLine("All approaches failed to get baseline");[m
[32m+[m[32m                LogToFile("All approaches failed to get baseline");[m
                 return null;[m
             }[m
             catch (Exception ex)[m
             {[m
[31m-                System.Diagnostics.Debug.WriteLine($"Error extracting baseline: {ex.Message}\n{ex.StackTrace}");[m
[32m+[m[32m                LogToFile($"Error extracting baseline: {ex.Message}\n{ex.StackTrace}");[m
                 return null;[m
             }[m
         }[m
 [m
[31m-        private object ExtractBaselineFromCurve(dynamic baseline)[m
[32m+[m[32m        private object ExtractBaselineFromCurve3D(Renga.ICurve3D baseline)[m
         {[m
             try[m
             {[m
[36m@@ -232,225 +269,166 @@[m [mnamespace RengaPlugin.Handlers[m
                     return null;[m
 [m
                 var baselineObj = new Dictionary<string, object>();[m
[31m-                var baselineType = baseline.GetType();[m
                 [m
[31m-                // Get curve type[m
[31m-                string curveTypeStr = "LineSegment";[m
[31m-                try[m
[31m-                {[m
[31m-                    var getCurveTypeMethod = baselineType.GetMethod("GetCurveType");[m
[31m-                    if (getCurveTypeMethod != null)[m
[31m-                    {[m
[31m-                        var curveType = getCurveTypeMethod.Invoke(baseline, null);[m
[31m-                        curveTypeStr = curveType?.ToString() ?? "LineSegment";[m
[31m-                        baselineObj["type"] = curveTypeStr;[m
[31m-                    }[m
[31m-                }[m
[31m-                catch[m
[31m-                {[m
[31m-                    baselineObj["type"] = curveTypeStr;[m
[31m-                }[m
[31m-[m
[32m+[m[32m                // Get curve type using ICurve3D interface[m
[32m+[m[32m                var curveType = baseline.Curve3DType;[m
[32m+[m[32m                string curveTypeStr = curveType.ToString();[m
[32m+[m[32m                baselineObj["type"] = curveTypeStr;[m
[32m+[m[41m                [m
                 // Get start and end points[m
                 try[m
                 {[m
[31m-                    var getStartPointMethod = baselineType.GetMethod("GetStartPoint");[m
[31m-                    var getEndPointMethod = baselineType.GetMethod("GetEndPoint");[m
[31m-                    if (getStartPointMethod != null && getEndPointMethod != null)[m
[31m-                    {[m
[31m-                        var startPoint = getStartPointMethod.Invoke(baseline, null);[m
[31m-                        var endPoint = getEndPointMethod.Invoke(baseline, null);[m
[31m-                        [m
[31m-                        if (startPoint != null && endPoint != null)[m
[31m-                        {[m
[31m-                            var pointType = startPoint.GetType();[m
[31m-                            var xProp = pointType.GetProperty("X");[m
[31m-                            var yProp = pointType.GetProperty("Y");[m
[31m-                            var zProp = pointType.GetProperty("Z");[m
[31m-                            [m
[31m-                            if (xProp != null && yProp != null && zProp != null)[m
[31m-                            {[m
[31m-                                baselineObj["startPoint"] = new { [m
[31m-                                    x = (double)xProp.GetValue(startPoint), [m
[31m-                                    y = (double)yProp.GetValue(startPoint), [m
[31m-                                    z = (double)zProp.GetValue(startPoint) [m
[31m-                                };[m
[31m-                                baselineObj["endPoint"] = new { [m
[31m-                                    x = (double)xProp.GetValue(endPoint), [m
[31m-                                    y = (double)yProp.GetValue(endPoint), [m
[31m-                                    z = (double)zProp.GetValue(endPoint) [m
[31m-                                };[m
[31m-                            }[m
[31m-                        }[m
[31m-                    }[m
[32m+[m[32m                    var startPoint = baseline.GetBeginPoint();[m
[32m+[m[32m                    var endPoint = baseline.GetEndPoint();[m
[32m+[m[41m                    [m
[32m+[m[32m                    baselineObj["startPoint"] = new {[m[41m [m
[32m+[m[32m                        x = startPoint.X,[m[41m [m
[32m+[m[32m                        y = startPoint.Y,[m[41m [m
[32m+[m[32m                        z = startPoint.Z[m[41m [m
[32m+[m[32m                    };[m
[32m+[m[32m                    baselineObj["endPoint"] = new {[m[41m [m
[32m+[m[32m                        x = endPoint.X,[m[41m [m
[32m+[m[32m                        y = endPoint.Y,[m[41m [m
[32m+[m[32m                        z = endPoint.Z[m[41m [m
[32m+[m[32m                    };[m
                 }[m
                 catch (Exception ex)[m
                 {[m
[31m-                    System.Diagnostics.Debug.WriteLine($"Error getting start/end points: {ex.Message}");[m
[32m+[m[32m                    LogToFile($"Error getting start/end points: {ex.Message}");[m
                 }[m
 [m
[31m-                // For polycurves, extract segments with exact 3D coordinates[m
[31m-                if (curveTypeStr.Contains("PolyCurve") || curveTypeStr.Contains("Polyline"))[m
[32m+[m[32m                // For polycurves, extract segments[m
[32m+[m[32m                if (baseline is Renga.IPolyCurve3D polyCurve)[m
                 {[m
                     var segments = new List<object>();[m
                     try[m
                     {[m
[31m-                        // Try to get segment count[m
[31m-                        var getSegmentCountMethod = baselineType.GetMethod("GetSegmentCount");[m
[31m-                        if (getSegmentCountMethod != null)[m
[32m+[m[32m                        int segmentCount = polyCurve.GetSegmentCount();[m
[32m+[m[32m                        for (int i = 0; i < segmentCount; i++)[m
                         {[m
[31m-                            int segmentCount = (int)getSegmentCountMethod.Invoke(baseline, null);[m
[31m-                            [m
[31m-                            // Get each segment[m
[31m-                            var getSegmentMethod = baselineType.GetMethod("GetSegment", new Type[] { typeof(int) });[m
[31m-                            if (getSegmentMethod != null)[m
[32m+[m[32m                            try[m
                             {[m
[31m-                                for (int i = 0; i < segmentCount; i++)[m
[31m-                                {[m
[31m-                                    try[m
[31m-                                    {[m
[31m-                                        var segment = getSegmentMethod.Invoke(baseline, new object[] { i });[m
[31m-                                        if (segment != null)[m
[31m-                                        {[m
[31m-                                            var segmentType = segment.GetType();[m
[31m-                                            var segObj = new Dictionary<string, object>();[m
[31m-                                            [m
[31m-                                            // Get segment type[m
[31m-                                            var segGetCurveTypeMethod = segmentType.GetMethod("GetCurveType");[m
[31m-                                            if (segGetCurveTypeMethod != null)[m
[31m-                                            {[m
[31m-                                                var segCurveType = segGetCurveTypeMethod.Invoke(segment, null);[m
[31m-                                                segObj["type"] = segCurveType?.ToString() ?? "LineSegment";[m
[31m-                                            }[m
[31m-                              